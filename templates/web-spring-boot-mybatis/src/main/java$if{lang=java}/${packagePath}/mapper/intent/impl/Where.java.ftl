/*  This class is generated by CodeMan */package ${packageName}.mapper.intent.impl;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class Where<T> extends WhereItem<T> {    private int level = 0;    private List<Where<T>> wheres;    public Where(Where<T> where) {        super(where);        this.level = where.level;        this.wheres = where.wheres;    }    public Where(String column, String op, Object value) {        this.op = op;        this.value = value;        this.column = column;    }    public Where(Where<T> left, String op, Where<T> right) {        this.op = op;        this.level = Math.max(left.level, right.level) + 1;        this.wheres = new ArrayList<>(Arrays.asList(left, right));        this.checkLevel();    }    @SafeVarargs    public final OrderWhere<T> orderBy(OrderQuery<T>... order) {        return new OrderWhere<T>(this).orderBy(order);    }    public boolean isMultCondition() {        return wheres != null;    }    public Where<T> or(Where<T> where) {        return merge(this, "OR", where);    }    public Where<T> and(Where<T> where) {        return merge(this, "AND", where);    }    private static <T> Where<T> merge(Where<T> left, String op, Where<T> right) {        if (left.isMultCondition() != right.isMultCondition()) {            if (left.isMultCondition()) {                return left.annex(right, op);            } else {                return right.annex(left, op);            }        } else if (left.isMultCondition() && right.isMultCondition()) {            if (op.equals(left.op)) {                return left.annex(right, op);            } else if (op.equals(right.op)) {                return right.annex(left, op);            } else {                return new Where<>(left, op, right);            }        }        return new Where<>(left, op, right);    }    private Where<T> annex(Where<T> where, String op) {        if (wheres == null) {            throw new RuntimeException("annex(Where,op)函数中，叶级别无法吞并！");        }        if (op.equals(this.op)) {            if (where.isMultCondition() && op.equals(where.op)) {                if (this.level < where.level) {                    this.level = where.level + 1;                }                this.wheres.addAll(where.wheres);            } else {                if (this.level <= where.level) {                    this.level = where.level + 1;                }                this.wheres.add(where);            }            this.checkLevel();            return this;        } else {            return new Where<>(this, op, where);        }    }    private void checkLevel() {        if (this.level > 3) {            throw new RuntimeException("checkLevel() = " + level + ", 不能超过2！");        }    }    public String getOp() {        return op;    }    public void setOp(String op) {        this.op = op;    }    public String getColumn() {        return column;    }    public void setColumn(String column) {        this.column = column;    }    public Object getValue() {        return value;    }    public void setValue(Object value) {        this.value = value;    }    public List<Where<T>> getWheres() {        return wheres;    }    public void setWheres(List<Where<T>> wheres) {        this.wheres = wheres;    }}