package ${packageName}.filterimport com.fasterxml.jackson.databind.JsonNodeimport com.fasterxml.jackson.databind.ObjectMapperimport org.apache.catalina.connector.CoyoteInputStreamimport org.apache.catalina.connector.InputBufferimport org.apache.coyote.Requestimport org.slf4j.Loggerimport org.slf4j.LoggerFactoryimport org.springframework.http.MediaTypeimport java.nio.ByteBufferimport java.nio.charset.StandardCharsetsimport java.util.*import javax.servlet.*import javax.servlet.http.HttpServletRequestimport javax.servlet.http.HttpServletRequestWrapperimport kotlin.streams.toList/** * Json参数解析过滤器 * 过滤器可以让 表单参数也可以接收 Json 请求 * * 由代码生成器生成，可以修改 * 但是如果删除，下次继续生成时，又会出现 * @author ${author} * @since ${now?string("yyyy-MM-dd zzzz")} */class JsonParamFilter (val jackson: ObjectMapper) : Filter {    companion object {        val log: Logger = LoggerFactory.getLogger(JsonParamFilter::class.java)    }    private class JsonParamHttpRequest(request: HttpServletRequest,val stream: ServletInputStream,val node: JsonNode) : HttpServletRequestWrapper(request) {        private var names: List<String>? = null        private var map: Map<String, Array<String>?>? = null        override fun getInputStream(): ServletInputStream {            return stream        }        override fun getParameterMap(): Map<String, Array<String>?>? {            if (map == null) {                map = parameterNames?.asSequence()?.map { it to getParameterValues(it) }?.toMap()            }            return map        }        override fun getParameterNames(): Enumeration<String>? {            this.names?.run { return Collections.enumeration(this) }            treefieldNames(this.node).toMutableList().run {                super.getParameterNames()?.let { addAll(it.toList()) }                return Collections.enumeration(this.apply { names = this })            }        }        override fun getParameter(name: String): String? {            treeNodeValue(node, name)?.run {                return valueFromNode(this)            }            return super.getParameter(name)        }        override fun getParameterValues(name: String): Array<String>? {            treeNodeValue(node, name)?.run {                return if (isArray) { map { valueFromNode(it) }.toTypedArray() } else arrayOf(valueFromNode(this))            }            return super.getParameterValues(name)        }        private fun valueFromNode(value: JsonNode): String {            return when {                value.isNull ->  ""                value.isTextual -> value.textValue()                value.isArray -> value.joinToString(",") { valueFromNode(it) }                else ->  value.toPrettyString()            }        }        fun treefieldNames(node: JsonNode, current: String? = null): Sequence<String>  {            return node.fieldNames()?.asSequence()?.flatMap {                return@flatMap node[it].run {                    val key = if(current == null) it else "$current.$it"                    if (this.isObject) {                        return@run treefieldNames(this, key)                    }                    return@run arrayOf(key).asSequence()                }            } ?: emptySequence()        }        fun treeNodeValue(node: JsonNode, path: String): JsonNode? {            node.get(path)?.run { return this }            path.indexOf('.').also { dot->                if (dot > 0) {                    node[path.substring(0, dot)]?.run {                        return treeNodeValue(this, path.substring(dot + 1))                    }                }            }            return null        }    }    override fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {        var useRequest: ServletRequest = request        if (request is HttpServletRequest && request.contentLength > 0) {            val contentType = request.contentType ?: ""            if (contentType.startsWith(MediaType.APPLICATION_JSON_VALUE, false)) {                val mediaType = MediaType.parseMediaType(contentType)                val charset = mediaType.charset ?: StandardCharsets.UTF_8                val reader = request.inputStream.bufferedReader(charset)                val json = reader.lines().toList().joinToString("")                val input = InputBuffer(32).apply { byteBuffer = ByteBuffer.wrap(json.toByteArray(charset));setRequest(Request()) }                useRequest = JsonParamHttpRequest(request, object : CoyoteInputStream(input) {  }, jackson.readTree(json))            }        }        chain.doFilter(useRequest, response)    }}